// app/api/generate-consultation-report/route.ts

import { type NextRequest, NextResponse } from "next/server"
import { generateText } from "ai"
import { openai } from "@ai-sdk/openai"

export async function POST(request: NextRequest) {
  try {
    console.log("üìã G√©n√©ration du dossier m√©dical complet")
    
    const { 
      patientData, 
      clinicalData, 
      questionsData, 
      diagnosisData,
      editedDocuments,
      generateAllDocuments = false
    } = await request.json()

    if (!patientData || !clinicalData || !diagnosisData) {
      return NextResponse.json(
        { success: false, error: "Donn√©es incompl√®tes" },
        { status: 400 }
      )
    }

    // Si on doit g√©n√©rer tous les documents
    if (generateAllDocuments) {
      console.log("ü§ñ G√©n√©ration compl√®te : compte rendu + ordonnances")
      
      // Extraire les informations cl√©s pour le prompt
      const patientInfo = {
        nom: `${patientData.firstName} ${patientData.lastName}`,
        age: patientData.age,
        sexe: patientData.gender?.[0] || patientData.gender,
        poids: patientData.weight,
        taille: patientData.height,
        allergies: Array.isArray(patientData.allergies) ? patientData.allergies.join(', ') : 'Aucune',
        antecedents: patientData.medicalHistory?.join(', ') || 'Aucun',
        adresse: patientData.address || 'Non renseign√©e',
        telephone: patientData.phone || patientData.phoneNumber || 'Non renseign√©'
      }

      const clinicalInfo = {
        motif: clinicalData.chiefComplaint,
        duree: clinicalData.symptomDuration,
        symptomes: clinicalData.symptoms?.join(', '),
        signesVitaux: clinicalData.vitalSigns,
        examenPhysique: clinicalData.physicalExamDetails
      }

      const diagnosticInfo = {
        principal: diagnosisData?.diagnosis?.primary?.condition || diagnosisData?.primary?.condition,
        differentiel: diagnosisData?.diagnosis?.differential || [],
        investigations: diagnosisData?.expertAnalysis?.expert_investigations,
        traitements: diagnosisData?.expertAnalysis?.expert_therapeutics
      }

      const completePrompt = `
Tu es un m√©decin senior exp√©riment√© √† Maurice cr√©ant un dossier m√©dical complet.

CONTEXTE PATIENT:
${JSON.stringify(patientInfo, null, 2)}

DONN√âES CLINIQUES:
${JSON.stringify(clinicalInfo, null, 2)}

DIAGNOSTIC ET ANALYSE:
${JSON.stringify(diagnosticInfo, null, 2)}

INSTRUCTIONS:
1. G√©n√®re un compte rendu professionnel en PROSE NARRATIVE fluide
2. G√©n√®re les 4 ordonnances compl√®tes bas√©es sur le diagnostic
3. Utilise la terminologie m√©dicale fran√ßaise appropri√©e
4. Adapte au contexte mauricien (disponibilit√©s, centres, etc.)
5. Int√®gre TOUTES les recommandations du diagnostic

RETOURNE UNIQUEMENT UN JSON VALIDE (sans markdown, sans backticks):

{
  "report": {
    "header": {
      "title": "COMPTE-RENDU DE CONSULTATION M√âDICALE",
      "subtitle": "M√©decine G√©n√©rale - Consultation du ${new Date().toLocaleDateString('fr-FR')}",
      "reference": "CR-${Date.now()}"
    },
    "identification": {
      "patient": "${patientInfo.nom}",
      "age": "${patientInfo.age} ans",
      "dateNaissance": "${patientData.birthDate || 'Non renseign√©e'}",
      "sexe": "${patientInfo.sexe}",
      "adresse": "${patientInfo.adresse}",
      "telephone": "${patientInfo.telephone}"
    },
    "rapport": {
      "motifConsultation": "[PROSE fluide d√©crivant pourquoi le patient consulte, int√©grant le motif et le contexte]",
      "anamnese": "[PROSE NARRATIVE d√©taill√©e racontant l'histoire de la maladie de mani√®re chronologique, incluant l'apparition des sympt√¥mes, leur √©volution, les facteurs aggravants, l'impact sur la vie quotidienne]",
      "antecedents": "[PROSE d√©crivant les ant√©c√©dents m√©dicaux, chirurgicaux, familiaux, allergies, habitudes de vie de mani√®re narrative]",
      "examenClinique": "[PROSE M√âDICALE AU PR√âSENT d√©crivant l'examen physique de mani√®re syst√©matique : √©tat g√©n√©ral, signes vitaux, examen par appareil]",
      "syntheseDiagnostique": "[PROSE exposant le raisonnement diagnostique, les hypoth√®ses envisag√©es et √©cart√©es]",
      "conclusionDiagnostique": "[PROSE concluant sur le diagnostic retenu avec les arguments cliniques]",
      "priseEnCharge": "[PROSE d√©taillant le plan th√©rapeutique : examens, traitements, mesures associ√©es]",
      "surveillance": "[PROSE d√©crivant le plan de surveillance, les signes d'alerte, le suivi recommand√©]",
      "conclusion": "[PROSE r√©sumant la consultation, le pronostic et les perspectives]"
    },
    "signature": {
      "medecin": "Dr. M√âDECIN EXPERT",
      "qualification": "M√©decin G√©n√©raliste",
      "rpps": "",
      "etablissement": "Cabinet M√©dical - Maurice"
    },
    "metadata": {
      "dateGeneration": "${new Date().toISOString()}",
      "dureeConsultation": "30 minutes",
      "typeConsultation": "Consultation initiale"
    }
  },
  
  "documents": {
    "consultation": {
      "header": {
        "title": "COMPTE-RENDU DE CONSULTATION",
        "subtitle": "M√©decine G√©n√©rale",
        "date": "${new Date().toISOString().split('T')[0]}",
        "time": "${new Date().toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' })}",
        "physician": "Dr. M√âDECIN EXPERT",
        "registration": "COUNCIL-MU-2024-001",
        "institution": "Centre M√©dical Maurice"
      },
      "patient": {
        "firstName": "${patientData.firstName}",
        "lastName": "${patientData.lastName}",
        "age": "${patientInfo.age} ans",
        "sex": "${patientInfo.sexe === 'Masculin' ? 'M' : 'F'}",
        "address": "${patientInfo.adresse}",
        "phone": "${patientInfo.telephone}",
        "weight": "${patientInfo.poids}",
        "height": "${patientInfo.taille}",
        "allergies": "${patientInfo.allergies}"
      },
      "content": {
        "chiefComplaint": "${clinicalInfo.motif}",
        "history": "[Anamn√®se compl√®te int√©grant tous les √©l√©ments cliniques]",
        "examination": "[Examen physique d√©taill√© avec constantes et examen par appareil]",
        "diagnosis": "[Diagnostic principal retenu]",
        "plan": "[Plan de prise en charge d√©taill√©]"
      }
    },
    
    "biology": {
      "header": {
        "title": "R√âPUBLIQUE DE MAURICE - ORDONNANCE M√âDICALE",
        "subtitle": "PRESCRIPTION D'EXAMENS BIOLOGIQUES",
        "date": "${new Date().toISOString().split('T')[0]}",
        "number": "BIO-MU-${Date.now()}",
        "physician": "Dr. M√âDECIN EXPERT",
        "registration": "COUNCIL-MU-2024-001"
      },
      "patient": {
        "firstName": "${patientData.firstName}",
        "lastName": "${patientData.lastName}",
        "age": "${patientInfo.age} ans",
        "address": "${patientInfo.adresse}"
      },
      "prescriptions": [
        ${generateBiologyPrescriptions(diagnosticInfo)}
      ]
    },
    
    "paraclinical": {
      "header": {
        "title": "R√âPUBLIQUE DE MAURICE - ORDONNANCE M√âDICALE",
        "subtitle": "PRESCRIPTION D'EXAMENS PARACLINIQUES",
        "date": "${new Date().toISOString().split('T')[0]}",
        "number": "PARA-MU-${Date.now()}",
        "physician": "Dr. M√âDECIN EXPERT",
        "registration": "COUNCIL-MU-2024-001"
      },
      "patient": {
        "firstName": "${patientData.firstName}",
        "lastName": "${patientData.lastName}",
        "age": "${patientInfo.age} ans",
        "address": "${patientInfo.adresse}"
      },
      "prescriptions": [
        ${generateParaclinicalPrescriptions(diagnosticInfo)}
      ]
    },
    
    "medication": {
      "header": {
        "title": "R√âPUBLIQUE DE MAURICE - ORDONNANCE M√âDICALE",
        "subtitle": "PRESCRIPTION TH√âRAPEUTIQUE",
        "date": "${new Date().toISOString().split('T')[0]}",
        "number": "MED-MU-${Date.now()}",
        "physician": "Dr. M√âDECIN EXPERT",
        "registration": "COUNCIL-MU-2024-001",
        "validity": "Ordonnance valable 3 mois"
      },
      "patient": {
        "firstName": "${patientData.firstName}",
        "lastName": "${patientData.lastName}",
        "age": "${patientInfo.age} ans",
        "weight": "${patientInfo.poids}",
        "allergies": "${patientInfo.allergies}",
        "address": "${patientInfo.adresse}",
        "pregnancy": "Non applicable"
      },
      "prescriptions": [
        ${generateMedicationPrescriptions(diagnosticInfo, patientInfo)}
      ],
      "clinicalAdvice": {
        "hydration": "Hydratation renforc√©e (2-3L/jour) adapt√©e au climat tropical de Maurice",
        "activity": "Repos relatif selon sympt√¥mes, √©viter efforts intenses aux heures chaudes (10h-16h)",
        "diet": "Alimentation √©quilibr√©e, privil√©gier fruits et l√©gumes locaux, √©viter aliments √©pic√©s si troubles digestifs",
        "mosquitoProtection": "Protection anti-moustiques INDISPENSABLE (dengue/chikungunya end√©miques) : r√©pulsifs, v√™tements longs, moustiquaire",
        "followUp": "Consultation de contr√¥le si pas d'am√©lioration sous 48-72h ou si aggravation des sympt√¥mes",
        "emergency": "Urgences Maurice: 999 (SAMU) ou 114 - Cliniques 24h: Apollo Bramwell (Moka), Wellkin (Moka), C-Care Darn√©"
      }
    }
  }
}
`

      console.log("ü§ñ Appel GPT-4 pour g√©n√©ration compl√®te...")
      
      const result = await generateText({
        model: openai("gpt-4o"),
        prompt: completePrompt,
        maxTokens: 10000,
        temperature: 0.3,
      })

      console.log("‚úÖ G√©n√©ration termin√©e, parsing du r√©sultat...")

      // Parser et valider la r√©ponse
      let responseData
      try {
        let cleanedResponse = result.text.trim()
        
        // Nettoyer toute trace de markdown
        cleanedResponse = cleanedResponse.replace(/^```json\s*/i, '')
        cleanedResponse = cleanedResponse.replace(/^```\s*/i, '')
        cleanedResponse = cleanedResponse.replace(/\s*```$/i, '')
        cleanedResponse = cleanedResponse.trim()
        
        responseData = JSON.parse(cleanedResponse)
        
        // Ajouter les m√©tadonn√©es
        if (responseData.report) {
          responseData.report.metadata = responseData.report.metadata || {}
          responseData.report.metadata.wordCount = countWords(JSON.stringify(responseData.report.rapport))
          responseData.report.metadata.generatedAt = new Date().toISOString()
        }
        
      } catch (error) {
        console.error("‚ùå Erreur parsing JSON:", error)
        console.error("R√©ponse brute (premiers 500 caract√®res):", result.text.substring(0, 500))
        throw new Error("Erreur de format dans la r√©ponse g√©n√©r√©e")
      }

      return NextResponse.json({
        success: true,
        report: responseData.report,
        documents: responseData.documents
      })

    } else {
      // G√©n√©ration simple du rapport seul (comportement original)
      console.log("üìÑ G√©n√©ration du compte rendu seul")
      
      const simplePrompt = `
Tu es un m√©decin senior r√©digeant un compte rendu professionnel.

CONTEXTE:
${JSON.stringify({ patientData, clinicalData, questionsData, diagnosisData }, null, 2)}

G√©n√®re UNIQUEMENT le compte rendu narratif (sans les ordonnances).

RETOURNE UN JSON VALIDE:
{
  "header": {...},
  "identification": {...},
  "rapport": {
    "motifConsultation": "[PROSE]",
    "anamnese": "[PROSE NARRATIVE]",
    "antecedents": "[PROSE]",
    "examenClinique": "[PROSE AU PR√âSENT]",
    "syntheseDiagnostique": "[PROSE]",
    "conclusionDiagnostique": "[PROSE]",
    "priseEnCharge": "[PROSE]",
    "surveillance": "[PROSE]",
    "conclusion": "[PROSE]"
  },
  "signature": {...}
}
`

      const result = await generateText({
        model: openai("gpt-4o"),
        prompt: simplePrompt,
        maxTokens: 6000,
        temperature: 0.3,
      })

      let reportData = JSON.parse(result.text.trim())

      return NextResponse.json({
        success: true,
        report: reportData
      })
    }

  } catch (error) {
    console.error("‚ùå Erreur g√©n√©ration:", error)
    return NextResponse.json(
      { 
        success: false, 
        error: error instanceof Error ? error.message : "Erreur inconnue lors de la g√©n√©ration"
      },
      { status: 500 }
    )
  }
}

// Fonctions helper pour g√©n√©rer les prescriptions depuis le diagnostic

function generateBiologyPrescriptions(diagnosticInfo: any): string {
  const prescriptions = []
  
  if (diagnosticInfo.investigations?.immediate_priority) {
    const biologyExams = diagnosticInfo.investigations.immediate_priority
      .filter((exam: any) => exam.category === 'biology')
    
    biologyExams.forEach((exam: any, index: number) => {
      prescriptions.push(`{
        "id": ${Date.now() + index},
        "exam": "${exam.examination || 'Examen biologique'}",
        "indication": "${exam.specific_indication || 'Selon contexte clinique'}",
        "urgency": "${mapUrgency(exam.urgency)}",
        "fasting": "${exam.fasting_required ? 'Oui - 8h' : 'Non'}",
        "expectedResults": "${exam.interpretation_keys || 'R√©sultats √† interpr√©ter selon contexte'}",
        "sampleType": "${exam.sample_type || 'Sang veineux'}",
        "contraindications": "Aucune",
        "mauritianAvailability": "${formatAvailability(exam.mauritius_availability)}",
        "cost": "${exam.mauritius_availability?.estimated_cost || '√Ä v√©rifier'}"
      }`)
    })
  }
  
  // Si pas d'examens, ajouter un template basique
  if (prescriptions.length === 0) {
    prescriptions.push(`{
      "id": ${Date.now()},
      "exam": "√Ä d√©finir selon √©volution",
      "indication": "Selon contexte clinique",
      "urgency": "Semi-urgent (24-48h)",
      "fasting": "Non",
      "expectedResults": "",
      "sampleType": "Sang veineux",
      "contraindications": "Aucune",
      "mauritianAvailability": "Disponible laboratoires Maurice",
      "cost": "√Ä v√©rifier"
    }`)
  }
  
  return prescriptions.join(',\n        ')
}

function generateParaclinicalPrescriptions(diagnosticInfo: any): string {
  const prescriptions = []
  
  if (diagnosticInfo.investigations?.immediate_priority) {
    const paraclinicalExams = diagnosticInfo.investigations.immediate_priority
      .filter((exam: any) => exam.category === 'imaging' || exam.category === 'functional')
    
    paraclinicalExams.forEach((exam: any, index: number) => {
      prescriptions.push(`{
        "id": ${Date.now() + index + 100},
        "category": "${mapExamCategory(exam.examination)}",
        "exam": "${exam.examination || 'Examen paraclinique'}",
        "indication": "${exam.specific_indication || 'Exploration compl√©mentaire'}",
        "urgency": "${mapUrgency(exam.urgency)}",
        "preparation": "${exam.patient_preparation || 'Aucune pr√©paration sp√©ciale'}",
        "contraindications": "${exam.contraindications || 'Aucune'}",
        "duration": "${exam.duration || '15-30 minutes'}",
        "mauritianAvailability": "${formatAvailability(exam.mauritius_availability)}",
        "cost": "${exam.mauritius_availability?.estimated_cost || 'Variable selon secteur'}"
      }`)
    })
  }
  
  if (prescriptions.length === 0) {
    prescriptions.push(`{
      "id": ${Date.now() + 100},
      "category": "",
      "exam": "√Ä d√©finir selon √©volution",
      "indication": "Si n√©cessaire",
      "urgency": "Programm√© (1-2 semaines)",
      "preparation": "Aucune",
      "contraindications": "Aucune",
      "duration": "Variable",
      "mauritianAvailability": "Centres publics et priv√©s",
      "cost": "√Ä v√©rifier"
    }`)
  }
  
  return prescriptions.join(',\n        ')
}

function generateMedicationPrescriptions(diagnosticInfo: any, patientInfo: any): string {
  const prescriptions = []
  const isElderly = parseInt(patientInfo.age) >= 65
  
  if (diagnosticInfo.traitements?.primary_treatments) {
    diagnosticInfo.traitements.primary_treatments.forEach((treatment: any, index: number) => {
      const dosing = treatment.dosing_regimen?.standard_adult || ""
      const elderlyDosing = treatment.dosing_regimen?.elderly_adjustment || dosing
      
      prescriptions.push(`{
        "id": ${Date.now() + index + 200},
        "class": "${mapTherapeuticClass(treatment.therapeutic_class)}",
        "dci": "${treatment.medication_dci || ''}",
        "brand": "${treatment.mauritius_availability?.brand_names?.join(' / ') || 'Marques locales'}",
        "dosage": "${isElderly && elderlyDosing ? elderlyDosing : dosing}",
        "frequency": "${extractFrequency(dosing)}",
        "duration": "${treatment.treatment_duration || '7 jours'}",
        "totalQuantity": "${calculateQuantity(dosing, treatment.treatment_duration)}",
        "indication": "${treatment.precise_indication || ''}",
        "administration": "${treatment.administration_route || 'Per os'}",
        "contraindications": "${treatment.contraindications_absolute?.join(', ') || '√Ä v√©rifier'}",
        "precautions": "${treatment.precautions || 'Respecter posologie'}",
        "monitoring": "${treatment.monitoring_parameters?.join(', ') || 'Efficacit√© et tol√©rance'}",
        "mauritianAvailability": "${treatment.mauritius_availability?.locally_available ? 'Disponible' : '√Ä commander'}",
        "cost": "${treatment.mauritius_availability?.private_sector_cost || '√Ä pr√©ciser'}"
      }`)
    })
  }
  
  if (prescriptions.length === 0) {
    prescriptions.push(`{
      "id": ${Date.now() + 200},
      "class": "",
      "dci": "",
      "brand": "",
      "dosage": "",
      "frequency": "√Ä d√©finir",
      "duration": "",
      "totalQuantity": "",
      "indication": "",
      "administration": "Per os",
      "contraindications": "√Ä v√©rifier",
      "precautions": "Respecter posologie",
      "monitoring": "Efficacit√© et tol√©rance",
      "mauritianAvailability": "√Ä v√©rifier",
      "cost": "√Ä pr√©ciser"
    }`)
  }
  
  return prescriptions.join(',\n        ')
}

// Fonctions utilitaires

function mapUrgency(urgency: string): string {
  switch(urgency?.toLowerCase()) {
    case 'immediate': return "Urgent (dans les heures)"
    case 'urgent': return "Semi-urgent (24-48h)"
    case 'routine': return "Programm√© (1-2 semaines)"
    default: return "Programm√© (1-2 semaines)"
  }
}

function mapExamCategory(examName: string): string {
  const name = examName?.toLowerCase() || ""
  if (name.includes('echo') || name.includes('√©cho')) return "√âchographie"
  if (name.includes('ecg')) return "Explorations cardiologiques"
  if (name.includes('scanner') || name.includes('tdm')) return "Scanner (TDM)"
  if (name.includes('irm')) return "IRM"
  if (name.includes('radio')) {
    if (name.includes('thorax')) return "Imagerie thoracique"
    if (name.includes('abdom')) return "Imagerie abdominale"
    return "Imagerie standard"
  }
  return "Autres examens"
}

function mapTherapeuticClass(classes: string[]): string {
  if (!classes || classes.length === 0) return "Autre"
  const classStr = classes.join(' ').toLowerCase()
  
  if (classStr.includes('antalgique') || classStr.includes('antipyr√©tique')) {
    return "Antalgique non opio√Øde"
  }
  if (classStr.includes('ains') || classStr.includes('anti-inflammatoire')) {
    return "Anti-inflammatoire non st√©ro√Ødien (AINS)"
  }
  if (classStr.includes('antibiotique') || classStr.includes('antibact√©rien')) {
    return "Antibiotique"
  }
  if (classStr.includes('cortico√Øde')) {
    return "Cortico√Øde"
  }
  if (classStr.includes('antihistaminique')) {
    return "Antihistaminique"
  }
  return "Autre"
}

function formatAvailability(availability: any): string {
  if (!availability) return "Disponible Maurice"
  
  if (availability.public_centers?.length > 0) {
    return `Disponible: ${availability.public_centers.slice(0, 3).join(', ')}`
  }
  
  return availability.locally_available ? 
    "Disponible secteur public et priv√©" : 
    "√Ä commander / Centres sp√©cialis√©s"
}

function extractFrequency(dosing: string): string {
  if (!dosing) return "3 fois par jour"
  
  if (dosing.includes('x 1/jour') || dosing.includes('1 fois')) return "1 fois par jour"
  if (dosing.includes('x 2/jour') || dosing.includes('2 fois')) return "2 fois par jour"
  if (dosing.includes('x 3/jour') || dosing.includes('3 fois')) return "3 fois par jour"
  if (dosing.includes('x 4/jour') || dosing.includes('4 fois')) return "4 fois par jour"
  if (dosing.includes('matin et soir')) return "Matin et soir"
  
  return "3 fois par jour"
}

function calculateQuantity(dosing: string, duration: string): string {
  const daysMatch = duration?.match(/(\d+)\s*(jour|day)/i)
  const days = daysMatch ? parseInt(daysMatch[1]) : 7
  
  let dailyDoses = 3
  if (dosing?.includes('x 1/jour')) dailyDoses = 1
  if (dosing?.includes('x 2/jour')) dailyDoses = 2
  if (dosing?.includes('x 4/jour')) dailyDoses = 4
  
  return `${days * dailyDoses} comprim√©s`
}

function countWords(text: string): number {
  return text.split(/\s+/).filter(word => word.length > 0).length
}
